// Code generated by Wire protocol buffer compiler, do not edit.
// Source: google.api.HttpRule in http.proto
package com.google.api

import android.os.Parcelable
import com.squareup.wire.AndroidMessage
import com.squareup.wire.FieldEncoding
import com.squareup.wire.Message
import com.squareup.wire.ProtoAdapter
import com.squareup.wire.ProtoReader
import com.squareup.wire.ProtoWriter
import com.squareup.wire.ReverseProtoWriter
import com.squareup.wire.Syntax.PROTO_3
import com.squareup.wire.WireField
import com.squareup.wire.`internal`.JvmField
import com.squareup.wire.`internal`.checkElementsNotNull
import com.squareup.wire.`internal`.countNonNull
import com.squareup.wire.`internal`.immutableCopyOf
import com.squareup.wire.`internal`.redactElements
import com.squareup.wire.`internal`.sanitize
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.collections.List
import okio.ByteString

/**
 * # gRPC Transcoding
 *
 * gRPC Transcoding is a feature for mapping between a gRPC method and one or
 * more HTTP REST endpoints. It allows developers to build a single API service
 * that supports both gRPC APIs and REST APIs. Many systems, including \[Google
 * APIs\](https://github.com/googleapis/googleapis),
 * \[Cloud Endpoints\](https://cloud.google.com/endpoints), \[gRPC
 * Gateway\](https://github.com/grpc-ecosystem/grpc-gateway),
 * and \[Envoy\](https://github.com/envoyproxy/envoy) proxy support this feature
 * and use it for large scale production services.
 *
 * `HttpRule` defines the schema of the gRPC/REST mapping. The mapping specifies
 * how different portions of the gRPC request message are mapped to the URL
 * path, URL query parameters, and HTTP request body. It also controls how the
 * gRPC response message is mapped to the HTTP response body. `HttpRule` is
 * typically specified as an `google.api.http` annotation on the gRPC method.
 *
 * Each mapping specifies a URL path template and an HTTP method. The path
 * template may refer to one or more fields in the gRPC request message, as long
 * as each field is a non-repeated field with a primitive (non-message) type.
 * The path template controls how fields of the request message are mapped to
 * the URL path.
 *
 * Example:
 *
 *     service Messaging {
 *       rpc GetMessage(GetMessageRequest) returns (Message) {
 *         option (google.api.http) = {
 *             get: "/v1/{name=messages/&#42;}"
 *         };
 *       }
 *     }
 *     message GetMessageRequest {
 *       string name = 1; // Mapped to URL path.
 *     }
 *     message Message {
 *       string text = 1; // The resource content.
 *     }
 *
 * This enables an HTTP REST to gRPC mapping as below:
 *
 * HTTP | gRPC
 * -----|-----
 * `GET /v1/messages/123456`  | `GetMessage(name: "messages/123456")`
 *
 * Any fields in the request message which are not bound by the path template
 * automatically become HTTP query parameters if there is no HTTP request body.
 * For example:
 *
 *     service Messaging {
 *       rpc GetMessage(GetMessageRequest) returns (Message) {
 *         option (google.api.http) = {
 *             get:"/v1/messages/{message_id}"
 *         };
 *       }
 *     }
 *     message GetMessageRequest {
 *       message SubMessage {
 *         string subfield = 1;
 *       }
 *       string message_id = 1; // Mapped to URL path.
 *       int64 revision = 2;    // Mapped to URL query parameter `revision`.
 *       SubMessage sub = 3;    // Mapped to URL query parameter `sub.subfield`.
 *     }
 *
 * This enables a HTTP JSON to RPC mapping as below:
 *
 * HTTP | gRPC
 * -----|-----
 * `GET /v1/messages/123456?revision=2&sub.subfield=foo` |
 * `GetMessage(message_id: "123456" revision: 2 sub: SubMessage(subfield:
 * "foo"))`
 *
 * Note that fields which are mapped to URL query parameters must have a
 * primitive type or a repeated primitive type or a non-repeated message type.
 * In the case of a repeated type, the parameter can be repeated in the URL
 * as `...?param=A&param=B`. In the case of a message type, each field of the
 * message is mapped to a separate parameter, such as
 * `...?foo.a=A&foo.b=B&foo.c=C`.
 *
 * For HTTP methods that allow a request body, the `body` field
 * specifies the mapping. Consider a REST update method on the
 * message resource collection:
 *
 *     service Messaging {
 *       rpc UpdateMessage(UpdateMessageRequest) returns (Message) {
 *         option (google.api.http) = {
 *           patch: "/v1/messages/{message_id}"
 *           body: "message"
 *         };
 *       }
 *     }
 *     message UpdateMessageRequest {
 *       string message_id = 1; // mapped to the URL
 *       Message message = 2;   // mapped to the body
 *     }
 *
 * The following HTTP JSON to RPC mapping is enabled, where the
 * representation of the JSON in the request body is determined by
 * protos JSON encoding:
 *
 * HTTP | gRPC
 * -----|-----
 * `PATCH /v1/messages/123456 { "text": "Hi!" }` | `UpdateMessage(message_id:
 * "123456" message { text: "Hi!" })`
 *
 * The special name `*` can be used in the body mapping to define that
 * every field not bound by the path template should be mapped to the
 * request body.  This enables the following alternative definition of
 * the update method:
 *
 *     service Messaging {
 *       rpc UpdateMessage(Message) returns (Message) {
 *         option (google.api.http) = {
 *           patch: "/v1/messages/{message_id}"
 *           body: "*"
 *         };
 *       }
 *     }
 *     message Message {
 *       string message_id = 1;
 *       string text = 2;
 *     }
 *
 *
 * The following HTTP JSON to RPC mapping is enabled:
 *
 * HTTP | gRPC
 * -----|-----
 * `PATCH /v1/messages/123456 { "text": "Hi!" }` | `UpdateMessage(message_id:
 * "123456" text: "Hi!")`
 *
 * Note that when using `*` in the body mapping, it is not possible to
 * have HTTP parameters, as all fields not bound by the path end in
 * the body. This makes this option more rarely used in practice when
 * defining REST APIs. The common usage of `*` is in custom methods
 * which don't use the URL at all for transferring data.
 *
 * It is possible to define multiple HTTP methods for one RPC by using
 * the `additional_bindings` option. Example:
 *
 *     service Messaging {
 *       rpc GetMessage(GetMessageRequest) returns (Message) {
 *         option (google.api.http) = {
 *           get: "/v1/messages/{message_id}"
 *           additional_bindings {
 *             get: "/v1/users/{user_id}/messages/{message_id}"
 *           }
 *         };
 *       }
 *     }
 *     message GetMessageRequest {
 *       string message_id = 1;
 *       string user_id = 2;
 *     }
 *
 * This enables the following two alternative HTTP JSON to RPC mappings:
 *
 * HTTP | gRPC
 * -----|-----
 * `GET /v1/messages/123456` | `GetMessage(message_id: "123456")`
 * `GET /v1/users/me/messages/123456` | `GetMessage(user_id: "me" message_id:
 * "123456")`
 *
 * ## Rules for HTTP mapping
 *
 * 1. Leaf request fields (recursive expansion nested messages in the request
 *    message) are classified into three categories:
 *    - Fields referred by the path template. They are passed via the URL path.
 *    - Fields referred by the \[HttpRule.body\]\[google.api.HttpRule.body\]. They
 *    are passed via the HTTP
 *      request body.
 *    - All other fields are passed via the URL query parameters, and the
 *      parameter name is the field path in the request message. A repeated
 *      field can be represented as multiple query parameters under the same
 *      name.
 *  2. If \[HttpRule.body\]\[google.api.HttpRule.body\] is "*", there is no URL
 *  query parameter, all fields
 *     are passed via URL path and HTTP request body.
 *  3. If \[HttpRule.body\]\[google.api.HttpRule.body\] is omitted, there is no HTTP
 *  request body, all
 *     fields are passed via URL path and URL query parameters.
 *
 * ### Path template syntax
 *
 *     Template = "/" Segments \[ Verb \] ;
 *     Segments = Segment { "/" Segment } ;
 *     Segment  = "*" | "**" | LITERAL | Variable ;
 *     Variable = "{" FieldPath \[ "=" Segments \] "}" ;
 *     FieldPath = IDENT { "." IDENT } ;
 *     Verb     = ":" LITERAL ;
 *
 * The syntax `*` matches a single URL path segment. The syntax `**` matches
 * zero or more URL path segments, which must be the last part of the URL path
 * except the `Verb`.
 *
 * The syntax `Variable` matches part of the URL path as specified by its
 * template. A variable template must not contain other variables. If a variable
 * matches a single path segment, its template may be omitted, e.g. `{var}`
 * is equivalent to `{var=*}`.
 *
 * The syntax `LITERAL` matches literal text in the URL path. If the `LITERAL`
 * contains any reserved character, such characters should be percent-encoded
 * before the matching.
 *
 * If a variable contains exactly one path segment, such as `"{var}"` or
 * `"{var=*}"`, when such a variable is expanded into a URL path on the client
 * side, all characters except `\[-_.~0-9a-zA-Z\]` are percent-encoded. The
 * server side does the reverse decoding. Such variables show up in the
 * \[Discovery
 * Document\](https://developers.google.com/discovery/v1/reference/apis) as
 * `{var}`.
 *
 * If a variable contains multiple path segments, such as `"{var=foo/&#42;}"`
 * or `"{var=**}"`, when such a variable is expanded into a URL path on the
 * client side, all characters except `\[-_.~/0-9a-zA-Z\]` are percent-encoded.
 * The server side does the reverse decoding, except "%2F" and "%2f" are left
 * unchanged. Such variables show up in the
 * \[Discovery
 * Document\](https://developers.google.com/discovery/v1/reference/apis) as
 * `{+var}`.
 *
 * ## Using gRPC API Service Configuration
 *
 * gRPC API Service Configuration (service config) is a configuration language
 * for configuring a gRPC service to become a user-facing product. The
 * service config is simply the YAML representation of the `google.api.Service`
 * proto message.
 *
 * As an alternative to annotating your proto file, you can configure gRPC
 * transcoding in your service config YAML files. You do this by specifying a
 * `HttpRule` that maps the gRPC method to a REST endpoint, achieving the same
 * effect as the proto annotation. This can be particularly useful if you
 * have a proto that is reused in multiple services. Note that any transcoding
 * specified in the service config will override any matching transcoding
 * configuration in the proto.
 *
 * Example:
 *
 *     http:
 *       rules:
 *         # Selects a gRPC method and applies HttpRule to it.
 *         - selector: example.v1.Messaging.GetMessage
 *           get: /v1/messages/{message_id}/{sub.subfield}
 *
 * ## Special notes
 *
 * When gRPC Transcoding is used to map a gRPC to JSON REST endpoints, the
 * proto to JSON conversion must follow the \[proto3
 * specification\](https://developers.google.com/protocol-buffers/docs/proto3#json).
 *
 * While the single segment variable follows the semantics of
 * \[RFC 6570\](https://tools.ietf.org/html/rfc6570) Section 3.2.2 Simple String
 * Expansion, the multi segment variable **does not** follow RFC 6570 Section
 * 3.2.3 Reserved Expansion. The reason is that the Reserved Expansion
 * does not expand special characters like `?` and `#`, which would lead
 * to invalid URLs. As the result, gRPC Transcoding uses a custom encoding
 * for multi segment variables.
 *
 * The path variables **must not** refer to any repeated or mapped field,
 * because client libraries are not capable of handling such variable expansion.
 *
 * The path variables **must not** capture the leading "/" character. The reason
 * is that the most common use case "{var}" does not capture the leading "/"
 * character. For consistency, all path variables must share the same behavior.
 *
 * Repeated message fields must not be mapped to URL query parameters, because
 * no client library can support such complicated mapping.
 *
 * If an API needs to use a JSON array for request or response body, it can map
 * the request or response body to a repeated field. However, some gRPC
 * Transcoding implementations may not support this feature.
 */
public class HttpRule(
  /**
   * Selects a method to which this rule applies.
   *
   * Refer to \[selector\]\[google.api.DocumentationRule.selector\] for syntax
   * details.
   */
  @field:WireField(
    tag = 1,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    label = WireField.Label.OMIT_IDENTITY,
    schemaIndex = 0,
  )
  @JvmField
  public val selector: String = "",
  /**
   * Maps to HTTP GET. Used for listing and getting information about
   * resources.
   */
  @field:WireField(
    tag = 2,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    declaredName = "get",
    oneofName = "pattern",
    schemaIndex = 1,
  )
  @JvmField
  public val get_: String? = null,
  /**
   * Maps to HTTP PUT. Used for replacing a resource.
   */
  @field:WireField(
    tag = 3,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    oneofName = "pattern",
    schemaIndex = 2,
  )
  @JvmField
  public val put: String? = null,
  /**
   * Maps to HTTP POST. Used for creating a resource or performing an action.
   */
  @field:WireField(
    tag = 4,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    oneofName = "pattern",
    schemaIndex = 3,
  )
  @JvmField
  public val post: String? = null,
  /**
   * Maps to HTTP DELETE. Used for deleting a resource.
   */
  @field:WireField(
    tag = 5,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    oneofName = "pattern",
    schemaIndex = 4,
  )
  @JvmField
  public val delete: String? = null,
  /**
   * Maps to HTTP PATCH. Used for updating a resource.
   */
  @field:WireField(
    tag = 6,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    oneofName = "pattern",
    schemaIndex = 5,
  )
  @JvmField
  public val patch: String? = null,
  /**
   * The custom pattern is used for specifying an HTTP method that is not
   * included in the `pattern` field, such as HEAD, or "*" to leave the
   * HTTP method unspecified for this rule. The wild-card rule is useful
   * for services that provide content to Web (HTML) clients.
   */
  @field:WireField(
    tag = 8,
    adapter = "com.google.api.CustomHttpPattern#ADAPTER",
    oneofName = "pattern",
    schemaIndex = 6,
  )
  @JvmField
  public val custom: CustomHttpPattern? = null,
  /**
   * The name of the request field whose value is mapped to the HTTP request
   * body, or `*` for mapping all request fields not captured by the path
   * pattern to the HTTP body, or omitted for not having any HTTP request body.
   *
   * NOTE: the referred field must be present at the top-level of the request
   * message type.
   */
  @field:WireField(
    tag = 7,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    label = WireField.Label.OMIT_IDENTITY,
    schemaIndex = 7,
  )
  @JvmField
  public val body: String = "",
  /**
   * Optional. The name of the response field whose value is mapped to the HTTP
   * response body. When omitted, the entire response message will be used
   * as the HTTP response body.
   *
   * NOTE: The referred field must be present at the top-level of the response
   * message type.
   */
  @field:WireField(
    tag = 12,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "responseBody",
    schemaIndex = 8,
  )
  @JvmField
  public val response_body: String = "",
  additional_bindings: List<HttpRule> = emptyList(),
  unknownFields: ByteString = ByteString.EMPTY,
) : AndroidMessage<HttpRule, HttpRule.Builder>(ADAPTER, unknownFields) {
  /**
   * Additional HTTP bindings for the selector. Nested bindings must
   * not contain an `additional_bindings` field themselves (that is,
   * the nesting may only be one level deep).
   */
  @field:WireField(
    tag = 11,
    adapter = "com.google.api.HttpRule#ADAPTER",
    label = WireField.Label.REPEATED,
    jsonName = "additionalBindings",
    schemaIndex = 9,
  )
  @JvmField
  public val additional_bindings: List<HttpRule> = immutableCopyOf("additional_bindings",
      additional_bindings)

  init {
    require(countNonNull(get_, put, post, delete, patch, custom) <= 1) {
      "At most one of get_, put, post, delete, patch, custom may be non-null"
    }
  }

  override fun newBuilder(): Builder {
    val builder = Builder()
    builder.selector = selector
    builder.get_ = get_
    builder.put = put
    builder.post = post
    builder.delete = delete
    builder.patch = patch
    builder.custom = custom
    builder.body = body
    builder.response_body = response_body
    builder.additional_bindings = additional_bindings
    builder.addUnknownFields(unknownFields)
    return builder
  }

  override fun equals(other: Any?): Boolean {
    if (other === this) return true
    if (other !is HttpRule) return false
    if (unknownFields != other.unknownFields) return false
    if (selector != other.selector) return false
    if (get_ != other.get_) return false
    if (put != other.put) return false
    if (post != other.post) return false
    if (delete != other.delete) return false
    if (patch != other.patch) return false
    if (custom != other.custom) return false
    if (body != other.body) return false
    if (response_body != other.response_body) return false
    if (additional_bindings != other.additional_bindings) return false
    return true
  }

  override fun hashCode(): Int {
    var result = super.hashCode
    if (result == 0) {
      result = unknownFields.hashCode()
      result = result * 37 + selector.hashCode()
      result = result * 37 + (get_?.hashCode() ?: 0)
      result = result * 37 + (put?.hashCode() ?: 0)
      result = result * 37 + (post?.hashCode() ?: 0)
      result = result * 37 + (delete?.hashCode() ?: 0)
      result = result * 37 + (patch?.hashCode() ?: 0)
      result = result * 37 + (custom?.hashCode() ?: 0)
      result = result * 37 + body.hashCode()
      result = result * 37 + response_body.hashCode()
      result = result * 37 + additional_bindings.hashCode()
      super.hashCode = result
    }
    return result
  }

  override fun toString(): String {
    val result = mutableListOf<String>()
    result += """selector=${sanitize(selector)}"""
    if (get_ != null) result += """get_=${sanitize(get_)}"""
    if (put != null) result += """put=${sanitize(put)}"""
    if (post != null) result += """post=${sanitize(post)}"""
    if (delete != null) result += """delete=${sanitize(delete)}"""
    if (patch != null) result += """patch=${sanitize(patch)}"""
    if (custom != null) result += """custom=$custom"""
    result += """body=${sanitize(body)}"""
    result += """response_body=${sanitize(response_body)}"""
    if (additional_bindings.isNotEmpty()) result += """additional_bindings=$additional_bindings"""
    return result.joinToString(prefix = "HttpRule{", separator = ", ", postfix = "}")
  }

  public fun copy(
    selector: String = this.selector,
    get_: String? = this.get_,
    put: String? = this.put,
    post: String? = this.post,
    delete: String? = this.delete,
    patch: String? = this.patch,
    custom: CustomHttpPattern? = this.custom,
    body: String = this.body,
    response_body: String = this.response_body,
    additional_bindings: List<HttpRule> = this.additional_bindings,
    unknownFields: ByteString = this.unknownFields,
  ): HttpRule = HttpRule(selector, get_, put, post, delete, patch, custom, body, response_body,
      additional_bindings, unknownFields)

  public class Builder : Message.Builder<HttpRule, Builder>() {
    @JvmField
    public var selector: String = ""

    @JvmField
    public var get_: String? = null

    @JvmField
    public var put: String? = null

    @JvmField
    public var post: String? = null

    @JvmField
    public var delete: String? = null

    @JvmField
    public var patch: String? = null

    @JvmField
    public var custom: CustomHttpPattern? = null

    @JvmField
    public var body: String = ""

    @JvmField
    public var response_body: String = ""

    @JvmField
    public var additional_bindings: List<HttpRule> = emptyList()

    /**
     * Selects a method to which this rule applies.
     *
     * Refer to \[selector\]\[google.api.DocumentationRule.selector\] for syntax
     * details.
     */
    public fun selector(selector: String): Builder {
      this.selector = selector
      return this
    }

    /**
     * The name of the request field whose value is mapped to the HTTP request
     * body, or `*` for mapping all request fields not captured by the path
     * pattern to the HTTP body, or omitted for not having any HTTP request body.
     *
     * NOTE: the referred field must be present at the top-level of the request
     * message type.
     */
    public fun body(body: String): Builder {
      this.body = body
      return this
    }

    /**
     * Optional. The name of the response field whose value is mapped to the HTTP
     * response body. When omitted, the entire response message will be used
     * as the HTTP response body.
     *
     * NOTE: The referred field must be present at the top-level of the response
     * message type.
     */
    public fun response_body(response_body: String): Builder {
      this.response_body = response_body
      return this
    }

    /**
     * Additional HTTP bindings for the selector. Nested bindings must
     * not contain an `additional_bindings` field themselves (that is,
     * the nesting may only be one level deep).
     */
    public fun additional_bindings(additional_bindings: List<HttpRule>): Builder {
      checkElementsNotNull(additional_bindings)
      this.additional_bindings = additional_bindings
      return this
    }

    /**
     * Maps to HTTP GET. Used for listing and getting information about
     * resources.
     */
    public fun get_(get_: String?): Builder {
      this.get_ = get_
      this.put = null
      this.post = null
      this.delete = null
      this.patch = null
      this.custom = null
      return this
    }

    /**
     * Maps to HTTP PUT. Used for replacing a resource.
     */
    public fun put(put: String?): Builder {
      this.put = put
      this.get_ = null
      this.post = null
      this.delete = null
      this.patch = null
      this.custom = null
      return this
    }

    /**
     * Maps to HTTP POST. Used for creating a resource or performing an action.
     */
    public fun post(post: String?): Builder {
      this.post = post
      this.get_ = null
      this.put = null
      this.delete = null
      this.patch = null
      this.custom = null
      return this
    }

    /**
     * Maps to HTTP DELETE. Used for deleting a resource.
     */
    public fun delete(delete: String?): Builder {
      this.delete = delete
      this.get_ = null
      this.put = null
      this.post = null
      this.patch = null
      this.custom = null
      return this
    }

    /**
     * Maps to HTTP PATCH. Used for updating a resource.
     */
    public fun patch(patch: String?): Builder {
      this.patch = patch
      this.get_ = null
      this.put = null
      this.post = null
      this.delete = null
      this.custom = null
      return this
    }

    /**
     * The custom pattern is used for specifying an HTTP method that is not
     * included in the `pattern` field, such as HEAD, or "*" to leave the
     * HTTP method unspecified for this rule. The wild-card rule is useful
     * for services that provide content to Web (HTML) clients.
     */
    public fun custom(custom: CustomHttpPattern?): Builder {
      this.custom = custom
      this.get_ = null
      this.put = null
      this.post = null
      this.delete = null
      this.patch = null
      return this
    }

    override fun build(): HttpRule = HttpRule(
      selector = selector,
      get_ = get_,
      put = put,
      post = post,
      delete = delete,
      patch = patch,
      custom = custom,
      body = body,
      response_body = response_body,
      additional_bindings = additional_bindings,
      unknownFields = buildUnknownFields()
    )
  }

  public companion object {
    @JvmField
    public val ADAPTER: ProtoAdapter<HttpRule> = object : ProtoAdapter<HttpRule>(
      FieldEncoding.LENGTH_DELIMITED, 
      HttpRule::class, 
      "type.googleapis.com/google.api.HttpRule", 
      PROTO_3, 
      null, 
      "http.proto"
    ) {
      override fun encodedSize(`value`: HttpRule): Int {
        var size = value.unknownFields.size
        if (value.selector != "") size += ProtoAdapter.STRING.encodedSizeWithTag(1, value.selector)
        size += ProtoAdapter.STRING.encodedSizeWithTag(2, value.get_)
        size += ProtoAdapter.STRING.encodedSizeWithTag(3, value.put)
        size += ProtoAdapter.STRING.encodedSizeWithTag(4, value.post)
        size += ProtoAdapter.STRING.encodedSizeWithTag(5, value.delete)
        size += ProtoAdapter.STRING.encodedSizeWithTag(6, value.patch)
        size += CustomHttpPattern.ADAPTER.encodedSizeWithTag(8, value.custom)
        if (value.body != "") size += ProtoAdapter.STRING.encodedSizeWithTag(7, value.body)
        if (value.response_body != "") size += ProtoAdapter.STRING.encodedSizeWithTag(12,
            value.response_body)
        size += HttpRule.ADAPTER.asRepeated().encodedSizeWithTag(11, value.additional_bindings)
        return size
      }

      override fun encode(writer: ProtoWriter, `value`: HttpRule) {
        if (value.selector != "") ProtoAdapter.STRING.encodeWithTag(writer, 1, value.selector)
        if (value.body != "") ProtoAdapter.STRING.encodeWithTag(writer, 7, value.body)
        if (value.response_body != "") ProtoAdapter.STRING.encodeWithTag(writer, 12,
            value.response_body)
        HttpRule.ADAPTER.asRepeated().encodeWithTag(writer, 11, value.additional_bindings)
        ProtoAdapter.STRING.encodeWithTag(writer, 2, value.get_)
        ProtoAdapter.STRING.encodeWithTag(writer, 3, value.put)
        ProtoAdapter.STRING.encodeWithTag(writer, 4, value.post)
        ProtoAdapter.STRING.encodeWithTag(writer, 5, value.delete)
        ProtoAdapter.STRING.encodeWithTag(writer, 6, value.patch)
        CustomHttpPattern.ADAPTER.encodeWithTag(writer, 8, value.custom)
        writer.writeBytes(value.unknownFields)
      }

      override fun encode(writer: ReverseProtoWriter, `value`: HttpRule) {
        writer.writeBytes(value.unknownFields)
        CustomHttpPattern.ADAPTER.encodeWithTag(writer, 8, value.custom)
        ProtoAdapter.STRING.encodeWithTag(writer, 6, value.patch)
        ProtoAdapter.STRING.encodeWithTag(writer, 5, value.delete)
        ProtoAdapter.STRING.encodeWithTag(writer, 4, value.post)
        ProtoAdapter.STRING.encodeWithTag(writer, 3, value.put)
        ProtoAdapter.STRING.encodeWithTag(writer, 2, value.get_)
        HttpRule.ADAPTER.asRepeated().encodeWithTag(writer, 11, value.additional_bindings)
        if (value.response_body != "") ProtoAdapter.STRING.encodeWithTag(writer, 12,
            value.response_body)
        if (value.body != "") ProtoAdapter.STRING.encodeWithTag(writer, 7, value.body)
        if (value.selector != "") ProtoAdapter.STRING.encodeWithTag(writer, 1, value.selector)
      }

      override fun decode(reader: ProtoReader): HttpRule {
        var selector: String = ""
        var get_: String? = null
        var put: String? = null
        var post: String? = null
        var delete: String? = null
        var patch: String? = null
        var custom: CustomHttpPattern? = null
        var body: String = ""
        var response_body: String = ""
        val additional_bindings = mutableListOf<HttpRule>()
        val unknownFields = reader.forEachTag { tag ->
          when (tag) {
            1 -> selector = ProtoAdapter.STRING.decode(reader)
            2 -> get_ = ProtoAdapter.STRING.decode(reader)
            3 -> put = ProtoAdapter.STRING.decode(reader)
            4 -> post = ProtoAdapter.STRING.decode(reader)
            5 -> delete = ProtoAdapter.STRING.decode(reader)
            6 -> patch = ProtoAdapter.STRING.decode(reader)
            8 -> custom = CustomHttpPattern.ADAPTER.decode(reader)
            7 -> body = ProtoAdapter.STRING.decode(reader)
            12 -> response_body = ProtoAdapter.STRING.decode(reader)
            11 -> additional_bindings.add(HttpRule.ADAPTER.decode(reader))
            else -> reader.readUnknownField(tag)
          }
        }
        return HttpRule(
          selector = selector,
          get_ = get_,
          put = put,
          post = post,
          delete = delete,
          patch = patch,
          custom = custom,
          body = body,
          response_body = response_body,
          additional_bindings = additional_bindings,
          unknownFields = unknownFields
        )
      }

      override fun redact(`value`: HttpRule): HttpRule = value.copy(
        custom = value.custom?.let(CustomHttpPattern.ADAPTER::redact),
        additional_bindings = value.additional_bindings.redactElements(HttpRule.ADAPTER),
        unknownFields = ByteString.EMPTY
      )
    }

    @JvmField
    public val CREATOR: Parcelable.Creator<HttpRule> = AndroidMessage.newCreator(ADAPTER)

    private const val serialVersionUID: Long = 0L
  }
}
